// element ui表单正则校验工具方法
export function elementValidator(reg, errorMessage) {
  return (rule, value, callback) => {
    if (!value) {
      callback()
      return
    }
    if (reg.test(value)) {
      callback()
    } else {
      callback(new Error(errorMessage))
    }
  }
}

// 常用的正则
export const regex = {
  // 非空
  required: /^.*[^\s].*$/,
  // 非空
  notBlank: /^.*[^\s].*$/,
  // 密码8-20位，需同时包含数字、特殊字符（英文状态）!@#$%^&*()以及字母
  password: /^(?=.*\d)(?=.*[a-zA-Z])(?=.*[!@#\$%\^&\*\(\)])[a-zA-Z0-9!@#\$%\^&\*\(\)]{8,20}$/,
  // 手机号码
  phone: /^[1][0-9]{10}$/,
  // 用户名，只能是字母或数字，4到16位字符
  username: /^[a-zA-Z0-9]{4,16}$/,
  // 姓名，只能是字母或中文，2到16位字符
  name: /^[a-zA-Z\u4E00-\u9FA5]{2,16}$/,
  // 数值
  number: /^-?[1-9][0-9]?.?[0-9]*$/,
  // 整数
  integer: /(^[1-9]\d*$)/,
  // 浮点数
  float: /^(-?\\d+)(\\.\\d+)?$/,
  // 字母和数字
  alphaNum: /^[a-zA-Z]+|[0-9]+$/,
  // 中文
  ch: /^[\u4e00-\u9fa5]+$/,
  // url地址
  url: /^(https?|ftp):\/\/([a-zA-Z0-9.-]+(:[a-zA-Z0-9.&%$-]+)*@)*((25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9][0-9]?)(\.(25[0-5]|2[0-4][0-9]|1[0-9]{2}|[1-9]?[0-9])){3}|([a-zA-Z0-9-]+\.)*[a-zA-Z0-9-]+\.(com|edu|gov|int|mil|net|org|biz|arpa|info|name|pro|aero|coop|museum|[a-zA-Z]{2}))(:[0-9]+)*(\/($|[a-zA-Z0-9.,?'\\+&%$#=~_-]+))*$/,
  // 身份证后6位
  lastCardNumber: /^\d{5}[\dxX]$/,
  // 18位身份证，15位已被淘汰
  idCard: /^[1-9]\d{5}(?:18|19|20)\d{2}(?:0\d|10|11|12)(?:0[1-9]|[1-2]\d|30|31)\d{3}[\dXx]$/,
  ipv4: /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/,
  ipv6: /^((([0-9A-Fa-f]{1,4}:){7}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}:[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){5}:([0-9A-Fa-f]{1,4}:)?[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){4}:([0-9A-Fa-f]{1,4}:){0,2}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){3}:([0-9A-Fa-f]{1,4}:){0,3}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){2}:([0-9A-Fa-f]{1,4}:){0,4}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){6}((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|(([0-9A-Fa-f]{1,4}:){0,5}:((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|(::([0-9A-Fa-f]{1,4}:){0,5}((\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b)\.){3}(\b((25[0-5])|(1\d{2})|(2[0-4]\d)|(\d{1,2}))\b))|([0-9A-Fa-f]{1,4}::([0-9A-Fa-f]{1,4}:){0,5}[0-9A-Fa-f]{1,4})|(::([0-9A-Fa-f]{1,4}:){0,6}[0-9A-Fa-f]{1,4})|(([0-9A-Fa-f]{1,4}:){1,7}:))$/i,
  // 统一社会信用代码
  creditNo: /^([0-9A-HJ-NPQRTUWXY]{2}\d{6}[0-9A-HJ-NPQRTUWXY]{10}|[1-9]\d{14})$/,
}

/**
 * 身份证校验
 */
export function validIDCard(idCard) {
  // 加权因子
  let weightFactor = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2]
  // 校验码
  let checkCode = ['1', '0', 'X', '9', '8', '7', '6', '5', '4', '3', '2']

  let code = idCard.toString()
  let last = idCard[17] // 最后一个

  let seventeen = code.substring(0, 17)

  // ISO 7064:1983.MOD 11-2
  // 判断最后一位校验码是否正确
  let arr = seventeen.split('')
  let len = arr.length
  let num = 0
  for (let i = 0; i < len; i++) {
    num = num + arr[i] * weightFactor[i]
  }

  // 获取余数
  let resisue = num % 11
  let lastNo = checkCode[resisue]

  // 格式的正则
  // 正则思路
  /*
  第一位不可能是0
  第二位到第六位可以是0-9
  第七位到第十位是年份，所以七八位为19或者20
  十一位和十二位是月份，这两位是01-12之间的数值
  十三位和十四位是日期，是从01-31之间的数值
  十五，十六，十七都是数字0-9
  十八位可能是数字0-9，也可能是X
  */
  let idcardPatter =
    /^[1-9][0-9]{5}([1][9][0-9]{2}|[2][0][0|1][0-9])([0][1-9]|[1][0|1|2])([0][1-9]|[1|2][0-9]|[3][0|1])[0-9]{3}([0-9]|[X])$/

  // 判断格式是否正确
  let format = idcardPatter.test(idCard)

  // 返回验证结果，校验码和格式同时正确才算是合法的身份证号码
  return !!(last === lastNo && format)
}

export default {
  elementValidator, // element ui表单正则校验工具方法
  regex, // 常用的正则
  validIDCard,
}
